{
  "\n        You are an expert in C unit testing for embedded systems, using the Unity test framework.\n        Your task is to generate a complete C unit test file for the provided source code.\n\n        You are given the source code to test AND the full content of its required header files for context.\n        Use this full context to create accurate tests.\n\n        ### Required Headers Context ###\n        \n        \n        ### Source Code to Test ###\n        ```c\n        #include \"../include/spi.h\" // Use the new header\n\n/**\n * @brief Writes a block of data to the SPI bus.\n * \n * @param data Pointer to the data buffer.\n * @param len The number of bytes to write. Must be > 0.\n * @return int 0 on success, error code otherwise.\n */\nint spi_write(uint8_t* data, uint16_t len) {\n    if (data == NULL) {\n        return SPI_ERROR_NULL_POINTER;\n    }\n\n    if (len == 0) {\n        return SPI_ERROR_INVALID_LENGTH;\n    }\n    \n    // Platform-specific SPI write logic would go here.\n    return SPI_SUCCESS;\n}\n\n        ```\n\n        Guidelines:\n        1.  Generate a complete, compilable C file that will not produce any compiler warnings.\n        2.  Include necessary headers (`unity.h`, `<stdlib.h>` if using malloc/free, and the header for the code under test).\n        3.  Create tests for success paths and all edge cases (NULL pointers, invalid values, etc.).\n        4.  Include `setUp()`, `tearDown()`, and a `main()` function.\n        5.  The `main()` function MUST use the standard Unity test runner format: `UNITY_BEGIN()`, followed by `RUN_TEST()` for each test function, and finally `return UNITY_END();`.\n            **Do not use the Unity Fixture style (`UnityMain`).**\n\n        Generate the complete unit test file now.\n        ": "```c\n#include \"unity.h\"\n#include \"spi.h\"\n#include <stdlib.h>\n#include <stdint.h>\n\n// setUp and tearDown required by Unity, even if empty\nvoid setUp(void) {}\nvoid tearDown(void) {}\n\n// Test: spi_write returns SPI_ERROR_NULL_POINTER on NULL data\nvoid test_spi_write_returns_error_on_null_pointer(void)\n{\n    uint16_t len = 5;\n    int result = spi_write(NULL, len);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write returns SPI_ERROR_INVALID_LENGTH on zero length\nvoid test_spi_write_returns_error_on_zero_length(void)\n{\n    uint8_t dummy = 0xAA;\n    int result = spi_write(&dummy, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_INVALID_LENGTH, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length 1)\nvoid test_spi_write_returns_success_on_valid_input_length_one(void)\n{\n    uint8_t data[1] = {0x12};\n    int result = spi_write(data, 1);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length > 1)\nvoid test_spi_write_returns_success_on_valid_input_length_multiple(void)\n{\n    uint8_t data[4] = {0x12, 0x34, 0xAA, 0x55};\n    int result = spi_write(data, 4);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write with NULL data and zero length returns the null pointer error, not the length error\nvoid test_spi_write_null_pointer_has_precedence_over_length_error(void)\n{\n    int result = spi_write(NULL, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write with large length (edge case)\nvoid test_spi_write_with_large_length(void)\n{\n    uint16_t len = 1024;\n    uint8_t *data = (uint8_t *)malloc(len);\n    TEST_ASSERT_NOT_NULL(data);\n\n    for (uint16_t i = 0; i < len; ++i) {\n        data[i] = (uint8_t)i;\n    }\n\n    int result = spi_write(data, len);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n\n    free(data);\n}\n\n// Test: spi_write with maximum uint16_t length (very large)\nvoid test_spi_write_with_max_uint16_length(void)\n{\n    uint16_t len = 0xFFFF;\n    // For memory safety, we won't allocate actual data. This just checks parameter passing.\n    int result = spi_write((uint8_t*)0x1, len); // non-NULL fake pointer\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(test_spi_write_returns_error_on_null_pointer);\n    RUN_TEST(test_spi_write_returns_error_on_zero_length);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_one);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_multiple);\n    RUN_TEST(test_spi_write_null_pointer_has_precedence_over_length_error);\n    RUN_TEST(test_spi_write_with_large_length);\n    RUN_TEST(test_spi_write_with_max_uint16_length);\n\n    return UNITY_END();\n}\n```",
  "\n            You are a senior C developer and QA engineer performing a code review.\n            Your task is to analyze the following C unit test code and identify any potential issues.\n            Treat compiler warnings (like 'implicit declaration of function') as errors that must be fixed.\n\n            The original source code being tested is:\n            ```c\n            #include \"../include/spi.h\" // Use the new header\n\n/**\n * @brief Writes a block of data to the SPI bus.\n * \n * @param data Pointer to the data buffer.\n * @param len The number of bytes to write. Must be > 0.\n * @return int 0 on success, error code otherwise.\n */\nint spi_write(uint8_t* data, uint16_t len) {\n    if (data == NULL) {\n        return SPI_ERROR_NULL_POINTER;\n    }\n\n    if (len == 0) {\n        return SPI_ERROR_INVALID_LENGTH;\n    }\n    \n    // Platform-specific SPI write logic would go here.\n    return SPI_SUCCESS;\n}\n\n            ```\n\n            Here is the generated unit test to review:\n            ```c\n            ```c\n#include \"unity.h\"\n#include \"spi.h\"\n#include <stdlib.h>\n#include <stdint.h>\n\n// setUp and tearDown required by Unity, even if empty\nvoid setUp(void) {}\nvoid tearDown(void) {}\n\n// Test: spi_write returns SPI_ERROR_NULL_POINTER on NULL data\nvoid test_spi_write_returns_error_on_null_pointer(void)\n{\n    uint16_t len = 5;\n    int result = spi_write(NULL, len);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write returns SPI_ERROR_INVALID_LENGTH on zero length\nvoid test_spi_write_returns_error_on_zero_length(void)\n{\n    uint8_t dummy = 0xAA;\n    int result = spi_write(&dummy, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_INVALID_LENGTH, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length 1)\nvoid test_spi_write_returns_success_on_valid_input_length_one(void)\n{\n    uint8_t data[1] = {0x12};\n    int result = spi_write(data, 1);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length > 1)\nvoid test_spi_write_returns_success_on_valid_input_length_multiple(void)\n{\n    uint8_t data[4] = {0x12, 0x34, 0xAA, 0x55};\n    int result = spi_write(data, 4);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write with NULL data and zero length returns the null pointer error, not the length error\nvoid test_spi_write_null_pointer_has_precedence_over_length_error(void)\n{\n    int result = spi_write(NULL, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write with large length (edge case)\nvoid test_spi_write_with_large_length(void)\n{\n    uint16_t len = 1024;\n    uint8_t *data = (uint8_t *)malloc(len);\n    TEST_ASSERT_NOT_NULL(data);\n\n    for (uint16_t i = 0; i < len; ++i) {\n        data[i] = (uint8_t)i;\n    }\n\n    int result = spi_write(data, len);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n\n    free(data);\n}\n\n// Test: spi_write with maximum uint16_t length (very large)\nvoid test_spi_write_with_max_uint16_length(void)\n{\n    uint16_t len = 0xFFFF;\n    // For memory safety, we won't allocate actual data. This just checks parameter passing.\n    int result = spi_write((uint8_t*)0x1, len); // non-NULL fake pointer\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(test_spi_write_returns_error_on_null_pointer);\n    RUN_TEST(test_spi_write_returns_error_on_zero_length);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_one);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_multiple);\n    RUN_TEST(test_spi_write_null_pointer_has_precedence_over_length_error);\n    RUN_TEST(test_spi_write_with_large_length);\n    RUN_TEST(test_spi_write_with_max_uint16_length);\n\n    return UNITY_END();\n}\n```\n            ```\n\n            Analyze the unit test for the following issues:\n            1.  **Compilation Errors & Warnings:** Will this code compile cleanly? Check for missing headers (e.g., `<stdlib.h>` for `malloc`), typos, or incorrect use of constants.\n            2.  **Correct `main` function:** The `main` function MUST use the standard Unity test runner format: `UNITY_BEGIN()`, followed by `RUN_TEST()` for each test function, and finally `return UNITY_END();`. Using the `UnityMain` style is an error.\n            3.  **Logic Errors:** Does the test correctly verify the intended behavior? Are the assertions correct?\n            4.  **Missing Coverage:** Does the test cover all important edge cases mentioned in the original code's comments or logic?\n\n            **Instructions:**\n            -   If you find any errors or warnings, provide a corrected, complete, and final version of the code inside a single C markdown block. Do not provide explanations outside the code block.\n            -   If the code is already perfect and has no errors or warnings, respond with ONLY the phrase \"The code is correct.\" and nothing else.\n            ": "```c\n#include \"unity.h\"\n#include \"spi.h\"\n#include <stdlib.h>\n#include <stdint.h>\n\n// setUp and tearDown required by Unity, even if empty\nvoid setUp(void) {}\nvoid tearDown(void) {}\n\n// Test: spi_write returns SPI_ERROR_NULL_POINTER on NULL data\nvoid test_spi_write_returns_error_on_null_pointer(void)\n{\n    uint16_t len = 5;\n    int result = spi_write(NULL, len);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write returns SPI_ERROR_INVALID_LENGTH on zero length\nvoid test_spi_write_returns_error_on_zero_length(void)\n{\n    uint8_t dummy = 0xAA;\n    int result = spi_write(&dummy, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_INVALID_LENGTH, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length 1)\nvoid test_spi_write_returns_success_on_valid_input_length_one(void)\n{\n    uint8_t data[1] = {0x12};\n    int result = spi_write(data, 1);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length > 1)\nvoid test_spi_write_returns_success_on_valid_input_length_multiple(void)\n{\n    uint8_t data[4] = {0x12, 0x34, 0xAA, 0x55};\n    int result = spi_write(data, 4);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write with NULL data and zero length returns the null pointer error, not the length error\nvoid test_spi_write_null_pointer_has_precedence_over_length_error(void)\n{\n    int result = spi_write(NULL, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write with large length (edge case)\nvoid test_spi_write_with_large_length(void)\n{\n    uint16_t len = 1024;\n    uint8_t *data = (uint8_t *)malloc(len);\n    TEST_ASSERT_NOT_NULL(data);\n\n    for (uint16_t i = 0; i < len; ++i) {\n        data[i] = (uint8_t)i;\n    }\n\n    int result = spi_write(data, len);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n\n    free(data);\n}\n\n// Test: spi_write with maximum uint16_t length (very large)\nvoid test_spi_write_with_max_uint16_length(void)\n{\n    uint16_t len = 0xFFFF;\n    // For memory safety, we won't allocate actual data. This just checks parameter passing.\n    // The pointer must be non-NULL and valid enough to not cause undefined behavior due to dereferencing in the function. \n    // Since the implementation does not dereference, this is safe.\n    int result = spi_write((uint8_t*)0x1, len); // non-NULL fake pointer\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(test_spi_write_returns_error_on_null_pointer);\n    RUN_TEST(test_spi_write_returns_error_on_zero_length);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_one);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_multiple);\n    RUN_TEST(test_spi_write_null_pointer_has_precedence_over_length_error);\n    RUN_TEST(test_spi_write_with_large_length);\n    RUN_TEST(test_spi_write_with_max_uint16_length);\n\n    return UNITY_END();\n}\n```",
  "\n            You are a senior C developer and QA engineer performing a code review.\n            Your task is to analyze the following C unit test code and identify any potential issues.\n            Treat compiler warnings (like 'implicit declaration of function') as errors that must be fixed.\n\n            The original source code being tested is:\n            ```c\n            #include \"../include/spi.h\" // Use the new header\n\n/**\n * @brief Writes a block of data to the SPI bus.\n * \n * @param data Pointer to the data buffer.\n * @param len The number of bytes to write. Must be > 0.\n * @return int 0 on success, error code otherwise.\n */\nint spi_write(uint8_t* data, uint16_t len) {\n    if (data == NULL) {\n        return SPI_ERROR_NULL_POINTER;\n    }\n\n    if (len == 0) {\n        return SPI_ERROR_INVALID_LENGTH;\n    }\n    \n    // Platform-specific SPI write logic would go here.\n    return SPI_SUCCESS;\n}\n\n            ```\n\n            Here is the generated unit test to review:\n            ```c\n            #include \"unity.h\"\n#include \"spi.h\"\n#include <stdlib.h>\n#include <stdint.h>\n\n// setUp and tearDown required by Unity, even if empty\nvoid setUp(void) {}\nvoid tearDown(void) {}\n\n// Test: spi_write returns SPI_ERROR_NULL_POINTER on NULL data\nvoid test_spi_write_returns_error_on_null_pointer(void)\n{\n    uint16_t len = 5;\n    int result = spi_write(NULL, len);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write returns SPI_ERROR_INVALID_LENGTH on zero length\nvoid test_spi_write_returns_error_on_zero_length(void)\n{\n    uint8_t dummy = 0xAA;\n    int result = spi_write(&dummy, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_INVALID_LENGTH, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length 1)\nvoid test_spi_write_returns_success_on_valid_input_length_one(void)\n{\n    uint8_t data[1] = {0x12};\n    int result = spi_write(data, 1);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write returns SPI_SUCCESS on valid arguments (length > 1)\nvoid test_spi_write_returns_success_on_valid_input_length_multiple(void)\n{\n    uint8_t data[4] = {0x12, 0x34, 0xAA, 0x55};\n    int result = spi_write(data, 4);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\n// Test: spi_write with NULL data and zero length returns the null pointer error, not the length error\nvoid test_spi_write_null_pointer_has_precedence_over_length_error(void)\n{\n    int result = spi_write(NULL, 0);\n    TEST_ASSERT_EQUAL_INT(SPI_ERROR_NULL_POINTER, result);\n}\n\n// Test: spi_write with large length (edge case)\nvoid test_spi_write_with_large_length(void)\n{\n    uint16_t len = 1024;\n    uint8_t *data = (uint8_t *)malloc(len);\n    TEST_ASSERT_NOT_NULL(data);\n\n    for (uint16_t i = 0; i < len; ++i) {\n        data[i] = (uint8_t)i;\n    }\n\n    int result = spi_write(data, len);\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n\n    free(data);\n}\n\n// Test: spi_write with maximum uint16_t length (very large)\nvoid test_spi_write_with_max_uint16_length(void)\n{\n    uint16_t len = 0xFFFF;\n    // For memory safety, we won't allocate actual data. This just checks parameter passing.\n    // The pointer must be non-NULL and valid enough to not cause undefined behavior due to dereferencing in the function. \n    // Since the implementation does not dereference, this is safe.\n    int result = spi_write((uint8_t*)0x1, len); // non-NULL fake pointer\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, result);\n}\n\nint main(void)\n{\n    UNITY_BEGIN();\n\n    RUN_TEST(test_spi_write_returns_error_on_null_pointer);\n    RUN_TEST(test_spi_write_returns_error_on_zero_length);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_one);\n    RUN_TEST(test_spi_write_returns_success_on_valid_input_length_multiple);\n    RUN_TEST(test_spi_write_null_pointer_has_precedence_over_length_error);\n    RUN_TEST(test_spi_write_with_large_length);\n    RUN_TEST(test_spi_write_with_max_uint16_length);\n\n    return UNITY_END();\n}\n            ```\n\n            Analyze the unit test for the following issues:\n            1.  **Compilation Errors & Warnings:** Will this code compile cleanly? Check for missing headers (e.g., `<stdlib.h>` for `malloc`), typos, or incorrect use of constants.\n            2.  **Correct `main` function:** The `main` function MUST use the standard Unity test runner format: `UNITY_BEGIN()`, followed by `RUN_TEST()` for each test function, and finally `return UNITY_END();`. Using the `UnityMain` style is an error.\n            3.  **Logic Errors:** Does the test correctly verify the intended behavior? Are the assertions correct?\n            4.  **Missing Coverage:** Does the test cover all important edge cases mentioned in the original code's comments or logic?\n\n            **Instructions:**\n            -   If you find any errors or warnings, provide a corrected, complete, and final version of the code inside a single C markdown block. Do not provide explanations outside the code block.\n            -   If the code is already perfect and has no errors or warnings, respond with ONLY the phrase \"The code is correct.\" and nothing else.\n            ": "The code is correct."
}