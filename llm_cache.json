{
  "\n            You are an expert C unit testing engineer. Generate a comprehensive test suite for the function(s) in `spi.c` based on the provided specification and source code.\n\n            ### Functional Requirements from Specification ###\n            ## `spi_init`\n\n### Description\nInitializes the SPI peripheral. This function must be called before any other SPI function.\n\n### Functional Requirements\n- The function must configure the SPI peripheral for Master Mode.\n- It must set the clock polarity and phase to Mode 0 (CPOL=0, CPHA=0).\n- The default clock speed must be set to 1 MHz.\n- On successful initialization, the internal driver state must be set to `SPI_STATE_INITIALIZED`.\n\n### Error Handling\n- If the SPI hardware is already initialized, the function must return `SPI_ERROR_ALREADY_INITIALIZED` without re-configuring the hardware.\n\n---\n\n## `spi_set_config`\n\n### Description\nConfigures the SPI clock speed and mode. Can only be called after `spi_init`.\n\n### Parameters\n- `config`: A pointer to an `spi_config_t` struct containing the desired configuration.\n\n### Functional Requirements\n- Must correctly apply the `speed_hz` and `mode` from the config struct to the hardware registers.\n- The `mode` parameter must be a value between 0 and 3, inclusive.\n- The `speed_hz` must be one of the following allowed values: 1000000 (1MHz), 4000000 (4MHz), 8000000 (8MHz).\n\n### Error Handling\n- If the driver has not been initialized via `spi_init`, the function must return `SPI_ERROR_NOT_INITIALIZED`.\n- If the `config` pointer is `NULL`, it must return `SPI_ERROR_NULL_POINTER`.\n- If an unsupported `mode` is provided, it must return `SPI_ERROR_INVALID_ARG`.\n- If an unsupported `speed_hz` is provided, it must return `SPI_ERROR_INVALID_ARG`.\n\n---\n\n## `spi_transfer`\n\n### Description\nTransmits a block of data and simultaneously receives a block of data.\n\n### Parameters\n- `tx_buffer`: A pointer to the data buffer to transmit. Can be `NULL` if only receiving data.\n- `rx_buffer`: A pointer to the buffer where received data will be stored. Can be `NULL` if only transmitting.\n- `len`: The number of bytes to transfer.\n\n### Functional Requirements\n- The function must perform a bidirectional transfer of `len` bytes.\n- If `tx_buffer` is `NULL`, the driver must transmit `0xFF` for the duration of the transfer.\n- If `rx_buffer` is `NULL`, received data must be discarded.\n- The maximum transfer length is 2048 bytes.\n\n### Error Handling\n- If the driver has not been initialized, it must return `SPI_ERROR_NOT_INITIALIZED`.\n- If both `tx_buffer` and `rx_buffer` are `NULL`, it must return `SPI_ERROR_INVALID_ARG`.\n- If `len` is 0 or greater than 2048, it must return `SPI_ERROR_INVALID_LENGTH`.\n\n            ### Source Code to Test ###\n            ```c\n            // File: my_c_project/src/spi.c\n\n#include \"spi.h\"\n#include <stdbool.h>\n\nstatic spi_state_t g_spi_state = SPI_STATE_UNINITIALIZED;\nstatic spi_config_t g_spi_config;\n\nstatic bool is_valid_speed(uint32_t speed) {\n    return (speed == 1000000 || speed == 4000000 || speed == 8000000);\n}\n\nint spi_init(void) {\n    if (g_spi_state != SPI_STATE_UNINITIALIZED) {\n        return SPI_ERROR_ALREADY_INITIALIZED;\n    }\n    g_spi_config.mode = 0;\n    g_spi_config.speed_hz = 1000000;\n    g_spi_state = SPI_STATE_INITIALIZED;\n    return SPI_SUCCESS;\n}\n\nint spi_set_config(const spi_config_t* config) {\n    if (g_spi_state == SPI_STATE_UNINITIALIZED) {\n        return SPI_ERROR_NOT_INITIALIZED;\n    }\n    if (config == NULL) {\n        return SPI_ERROR_NULL_POINTER;\n    }\n    if (config->mode > 3) {\n        return SPI_ERROR_INVALID_ARG;\n    }\n    if (!is_valid_speed(config->speed_hz)) {\n        return SPI_ERROR_INVALID_ARG;\n    }\n    g_spi_config = *config;\n    return SPI_SUCCESS;\n}\n\nint spi_transfer(const uint8_t* tx_buffer, uint8_t* rx_buffer, uint16_t len) {\n    if (g_spi_state == SPI_STATE_UNINITIALIZED) {\n        return SPI_ERROR_NOT_INITIALIZED;\n    }\n    if (tx_buffer == NULL && rx_buffer == NULL) {\n        return SPI_ERROR_INVALID_ARG;\n    }\n    if (len == 0 || len > 2048) {\n        return SPI_ERROR_INVALID_LENGTH;\n    }\n    g_spi_state = SPI_STATE_BUSY;\n    for (uint16_t i = 0; i < len; ++i) {\n        uint8_t tx_byte = (tx_buffer) ? tx_buffer[i] : 0xFF;\n        uint8_t rx_byte = tx_byte;\n        if (rx_buffer) {\n            rx_buffer[i] = rx_byte;\n        }\n    }\n    g_spi_state = SPI_STATE_INITIALIZED;\n    return SPI_SUCCESS;\n}\n\n// --- Test-only helper implementations ---\n#ifdef TEST\nspi_state_t test_spi_get_state(void) {\n    return g_spi_state;\n}\nspi_config_t test_spi_get_config(void) {\n    return g_spi_config;\n}\n#endif\n            ```\n            \n            **Task:** Write a complete C file containing Unity tests. The tests should be thorough and cover all requirements.\n            ": "```c\n// File: test/test_spi.c\n\n#include \"unity.h\"\n#include \"spi.h\"\n\n// Tell spi.c we're running in test mode, so test helpers are compiled in.\n#define TEST\n// Re-include the implementation for access to test-only helpers.\n#include \"../src/spi.c\"\n\n// Helper macros for repeated test patterns\n#define SPI_CONFIG_VALID_1MHZ    { .mode = 0, .speed_hz = 1000000 }\n#define SPI_CONFIG_VALID_4MHZ    { .mode = 1, .speed_hz = 4000000 }\n#define SPI_CONFIG_VALID_8MHZ    { .mode = 2, .speed_hz = 8000000 }\n#define SPI_CONFIG_INVALID_MODE  { .mode = 4, .speed_hz = 1000000 }\n#define SPI_CONFIG_INVALID_SPEED { .mode = 0, .speed_hz = 12345 }\n\n// Called before each test\nvoid setUp(void) {\n    // Reset global state between tests\n    extern spi_state_t g_spi_state;\n    extern spi_config_t g_spi_config;\n    g_spi_state = SPI_STATE_UNINITIALIZED;\n    g_spi_config.mode = 0xFF;\n    g_spi_config.speed_hz = 0xDEADBEEF;\n}\n\n// Called after each test\nvoid tearDown(void) {}\n\n// =============================\n//           TESTS\n// =============================\n\n// -------- spi_init() --------\nvoid test_spi_init_initializes_when_uninitialized(void) {\n    int ret = spi_init();\n    TEST_ASSERT_EQUAL_INT(SPI_SUCCESS, ret);\n    // Confirm state and config\n    TEST_ASSERT_EQUAL(SPI_STATE_INITIALIZED, test_spi_get_state());\n    spi_config_t config = test_spi_get_config();\n    TEST_ASSERT_EQUAL_UINT32(1000000, config.speed_hz);\n    TEST_ASSERT_EQUAL_UINT8(0, config.mode);\n}\n\nvoid test_spi_init_returns_error_when_already_initialized(void) {\n    // First call should initialize\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n    // Second call returns \"already initialized\"\n    int ret = spi_init();\n    TEST_ASSERT_EQUAL(SPI_ERROR_ALREADY_INITIALIZED, ret);\n    // State unchanged\n    TEST_ASSERT_EQUAL(SPI_STATE_INITIALIZED, test_spi_get_state());\n}\n\n// -------- spi_set_config() --------\nvoid test_spi_set_config_success_various_modes_and_speeds(void) {\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n\n    spi_config_t config = SPI_CONFIG_VALID_1MHZ;\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_set_config(&config));\n    spi_config_t r = test_spi_get_config();\n    TEST_ASSERT_EQUAL_UINT32(1000000, r.speed_hz);\n    TEST_ASSERT_EQUAL_UINT8(0, r.mode);\n\n    config.mode = 1; config.speed_hz = 4000000;\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_set_config(&config));\n    r = test_spi_get_config();\n    TEST_ASSERT_EQUAL_UINT32(4000000, r.speed_hz);\n    TEST_ASSERT_EQUAL_UINT8(1, r.mode);\n\n    config.mode = 3; config.speed_hz = 8000000;\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_set_config(&config));\n    r = test_spi_get_config();\n    TEST_ASSERT_EQUAL_UINT32(8000000, r.speed_hz);\n    TEST_ASSERT_EQUAL_UINT8(3, r.mode);\n}\n\nvoid test_spi_set_config_fails_not_initialized(void) {\n    spi_config_t config = SPI_CONFIG_VALID_1MHZ;\n    int ret = spi_set_config(&config);\n    TEST_ASSERT_EQUAL(SPI_ERROR_NOT_INITIALIZED, ret);\n}\n\nvoid test_spi_set_config_fails_if_config_is_null(void) {\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n    int ret = spi_set_config(NULL);\n    TEST_ASSERT_EQUAL(SPI_ERROR_NULL_POINTER, ret);\n}\n\nvoid test_spi_set_config_fails_if_mode_invalid(void) {\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n    spi_config_t config = SPI_CONFIG_INVALID_MODE;\n    int ret = spi_set_config(&config);\n    TEST_ASSERT_EQUAL(SPI_ERROR_INVALID_ARG, ret);\n}\n\nvoid test_spi_set_config_fails_if_speed_invalid(void) {\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n    spi_config_t config = SPI_CONFIG_INVALID_SPEED;\n    int ret = spi_set_config(&config);\n    TEST_ASSERT_EQUAL(SPI_ERROR_INVALID_ARG, ret);\n}\n\n// -------- spi_transfer() --------\nvoid test_spi_transfer_successful_full_duplex(void) {\n    TEST_ASSERT_EQUAL(SPI_SUCCESS, spi_init());\n    uint8_t tx[4] = {0x12, 0x34, 0x56, 0x78};\n    uint8_t rx[4] = {0, 0, 0, 0};\n    int ret = spi_transfer"
}